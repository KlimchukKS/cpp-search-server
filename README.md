# **Search Server**

## **Описание**

Данный проект представляет собой упрощённую реализацию поискового сервера, которая позволяет хранить документы, стоп-слова, а также осуществлять поиск по ключевым словам с возможностью ранжирования найденных документов по статистической метрике TF-IDF.

Дополнительные возможности:
* учёт минус-слов при поиске (исключение содержищих их документов из результата)
* использование многопоточности
* создание и обработка очереди запросов
* постраничный вывод результатов поиска

## **Работа с проектом**

### **Класс SearchServer**

Создание экземпляра класса осуществляется с помощью конструктора, в который передаётся набор стоп-слов в виде строки. Также есть возможность передать вместо строки произвольный контейнер, который должен поддерживать range-based for цикл

Пример:

```cpp
SearchServer search_server("and with in"s)
```
### **Добавление документов**

Метод AddDocuments позволяет пользователю добавить документ: для этого в качестве параметров ему нужно передать id документа, его содержимое (в виде строки), статус и рейтинг (в виде вектора)

Пример:

```cpp
search_server.AddDocument(10, "white cat and yellow hat"s, DocumentStatus::ACTUAL, { 1, 2 })
```
### **Поиск по документам**

Поиск по документам реализован через метод FindTopDocuments, результатом работы которого является вектор найденных документов. Фильтрация и ранжирование документов может быть выполнено по-разному, в зависимости от переданных методу аргументов:

* строка - по ней высчитывается релевантность документов по метрике TF-IDF
* статус - ACTUAL, IRRELEVANT, BANNED, REMOVED
* тип выполнения - последовательный, параллельный
* предикат, в котором указаны параметры филтрации

Пример:

```cpp
search_server.FindTopDocuments(execution::par, "curly nasty cat"s, [](int document_id, DocumentStatus status, int rating) { return document_id % 2 == 0; })
```
### **Обработка очереди запросов**

С помощью методов ProcessQueries и ProcessQueriesJoined можно параллельно обрабатывать несколько запросов. Первый из них возвращает вектор результатов поиска (вектор векторов), второй возвращает список (плоское представление)

Пример:

```cpp
const vector<string> queries = {
    "nasty rat -not"s,
    "not very funny nasty pet"s,
    "curly hair"s
};
for (const Document& document : ProcessQueriesJoined(search_server, queries)) {
    cout << "Document "s << document.id << " matched with relevance "s << document.relevance << endl;
}
```

### **Постраничный вывод**

Класс Paginator реализует поддержку постраничного вывода документов. Для взаимодействия с ним используется шаблонный метод Paginate, в который передаётся вектор найденных документов и желаемый размер страницы вывода.

Пример:

```cpp
const auto search_results = search_server.FindTopDocuments("curly dog"s);
const int page_size = 2;
const auto pages = Paginate(search_results, page_size);
for (auto page = pages.begin(); page != pages.end(); ++page) {
    cout << *page << endl;
    cout << "Page break"s << endl;
}
```

## **Системные требования**

Компилятор С++ с поддержкой стандарта C++17 или новее

## **Сборка**

Сборка осуществляется с помощью IDE (поддержка C++17) или командной строки
